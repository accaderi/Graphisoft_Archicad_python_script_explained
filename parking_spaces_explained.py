# Import archicad connection (required).
from archicad import ACConnection
# Import typing and string not essential for the code.
from typing import List, Tuple, Iterable
# Import itertools cycle method to use when we define the order of numbering in the rows.
# It gives back the list over and over again.
from itertools import cycle

# Establish the connection with the Archicad software, Archicad must be open and the pln file must be open too.
#
# We can use the acu.OpenFile() utility but we need an established connection first so we need to open Archicad and a new plan
# as a minimum because all utilities use the connection.
conn = ACConnection.connect()
# assert that the connection is alive
assert conn

# Create shorts of the commands, types and utilities.
acc = conn.commands
act = conn.types
acu = conn.utilities

# original comment -> ################################ CONFIGURATION #################################
# Getting the property Id (guid) for the General_ElementID property
# in order to use this to identify
# the property exactly when we communicate with the API
# (this is a unique identifier like our social security number).
propertyId = acu.GetBuiltInPropertyId('General_ElementID')
# This will be the id prefix used in the element id string
propertyValueStringPrefix = 'P '

# This is a method for collecting all the parking spaces from the Archicad pln file in a list.
# We need the 'guid' of the classificationItem in order to uniquely identify the classification
# based on we want to collect the elements with the Get elements by classification method.
classificationItem = acu.FindClassificationItemInSystem(
    'ARCHICAD Classification', 'Parking Space')

# We collect the parking spaces in the element list using the chair classification 'guid' from above.
# The elements list contains the 'guids' of the chairs.
# The length of the list is the total number of parking spaces in the project.
elements = acc.GetElementsByClassification(
    classificationItem.classificationItemId)

# These variables are to consider some kind of tolerance in the 'z' and 'y' coordinate of the parking space positions
# when we are sorting them by the level and the side of the building where they are.
# For that particular example this wouldn't be necessary since all the parking spaces
# are placed exactly on the same levels and they are sharing the exact same y coordinates.
# These tolerances are useful, when we want to select some elements in a certain strip or area.
# To consider some tolerances for example we can give upper and lower limit too.
ROW_GROUPING_LIMIT = 0.25
STORY_GROUPING_LIMIT = 1

# With this function we generate a string property value for the 'General_ElementID'
# since this is a string type property.
# Takes as argument the storyIndex (1, 2), elemIndex (01, 02, etc.)
# and using the propertyValueStringPrefix variable as the first character of the string. 
# The function returns a string e.g.: 'P 112'
def GeneratePropertyValueString(storyIndex: int, elemIndex: int) -> str:
    # storyIndex 1 digits, elemIndex 2 digits and below 10 it starts with 0.
    return f"{propertyValueStringPrefix}{storyIndex:1d}{elemIndex:02d}"
# original comment -> ################################################################################

# This function prepares NormalStringPropertyValue type from the string
# generated by the function 'GeneratePropertyValueString'.
# The function of GeneratePropertyValueString could be combined with this
# since these two functions are working always together.
def generatePropertyValue(storyIndex: int, elemIndex: int) -> act.NormalStringPropertyValue:
    return act.NormalStringPropertyValue(GeneratePropertyValueString(storyIndex, elemIndex))

# Create a list of the different levels and parking space rows.
# Arguments: List of elements' zMin values, yMin values, tolerance limit.
# Returns list of tuples(zMin, zMax) with the different levels or
# (yMin, yMax) with the different row y coordinate.
# The Min and Max values are always equal in our case.
def createClusters(positions: Iterable[float], limit: float) -> List[Tuple[float, float]]:
    # When we are getting the parking spaces to the elements list
    # the order of the parking spaces is not following our particular logic.
    # For that reason 'positions' needs to be sorted to avoid duplicates in the 'clusters' list.
    positions = sorted(positions)
    # If there is no elements nothing to sort so return an empty list.
    # In our case we always have elemnts so this check is redundant.
    if len(positions) == 0:
        return []
    # Create empty list for the end result
    clusters = []
    # Make the 'position' list iterabel. The list is iterable so this is not required.
    posIter = iter(positions)
    # All postions are equel to the first position in the 'positions' list.
    # In our case we would only need 1 position i.e. firstPos.
    firstPos = lastPos = next(posIter)

    # Loop all the position and append to the 'clusters' list
    for pos in posIter:
    # the different levels or row y coordinate only.
    # If the actual position - lastPos which is the start at the beginning <= limit (could be == 0).
        if pos - lastPos <= limit:
            # Take the actual position as the last one and continue with the next position.
            lastPos = pos
            # Else (the actual position - last position > limit (could be > 0)).
        else:
            # Append the first and last position tuple to the clusters list.
            # Fisrt position and last position are always equal in our case.
            clusters.append((firstPos, lastPos))
            # Update all the positions to be equal to pos and continue with the next position.
            firstPos = lastPos = pos
    # The last position will not reach the else statement because of the lack of next different value,
    # In order to be this value also added to the 'clusters' list we need to append this after the loop finishes.
    clusters.append((firstPos, lastPos))
    return clusters


# Getting all 3d bounding boxes of all the parking spaces.
# The bounding box contains the x, y, z minimum and maximum values of the box
# can be drawn around the element containging the whole element!
# Returns a list.
boundingBoxes = acc.Get3DBoundingBoxes(elements)
# List of each elements and its bounding box follows.
# Calling zip method on the elements list and the bounding box list.
elementBoundingBoxes = list(zip(elements, boundingBoxes))
# We create the list of the different values of the levels where the parking spaces are located on.
# Arguments: zMin values of the parking spaces, limit which is the tolerance of the level.
zClusters = createClusters((bb.boundingBox3D.zMin for bb in boundingBoxes), STORY_GROUPING_LIMIT)

# StoryIndex will increase when all parking zones on the actual story have their property values generated
# and appended to the elemPropertyValues list.
storyIndex = 0
elemPropertyValues = []
# Loop through all the parking spaces taking the zMin and zMax.
# These two values are the same practically and in that sense only the zMin positin would be enough.
for (zMin, zMax) in zClusters:
    # Initialise elemIndex with 1 as the first parking space element on the actual floor.
    elemIndex = 1
    # Using list comprehension we prepare a list with the all the parking spaces on the same level.
    elemsOnStory = [e for e in elementBoundingBoxes if zMin <= e[1].boundingBox3D.zMin <= zMax]
    # Based on the above created list with all parking spaces on the actual floor
    # we are creating 'clusters' list with the row y coordinates.
    yClusters = createClusters((e[1].boundingBox3D.yMin for e in elemsOnStory), ROW_GROUPING_LIMIT)

    # This loop takes the y Min and Y Max coordinates and the row boolean list zipped and
    # prepares the final values of the parking space numbers.
    for ((yMin, yMax), reverseOrder) in zip(yClusters, cycle([False, True])):
        # With list comprehension we are taking the parking spaces on the actual level for the actual row only.
        elemsInRow = [e for e in elemsOnStory
                        if yMin <= e[1].boundingBox3D.yMin <= yMax]

        # This loop generate the property values of the parking spaces on the actual floor and in the actual row
        # Taking the list of the elementsInRow sorted by the xMin values and ordered by the boolean value
        # which depends on the row.
        for (elem, bb) in sorted(elemsInRow, key=lambda e: e[1].boundingBox3D.xMin, reverse=reverseOrder):
            # Preparing and appending the property values to the final elemPropertyValues list
            # Archicad API type used: ElementPropertyValue()
            # Arguments: elementId, propertyId,
            # the string of the value created by the generatePropertyValue function
            # taking as arguments the storyIndex (level), elemIndex (index of the parking space number).
            elemPropertyValues.append(act.ElementPropertyValue(
                elem.elementId, propertyId, generatePropertyValue(storyIndex, elemIndex)))
            # Increase elemIndex to go to the next element.
            elemIndex += 1
    # Increase the storyIndex to go to the next story
    storyIndex += 1

# Set the new property values.
# Argument: elemPropertyValues list.
acc.SetPropertyValuesOfElements(elemPropertyValues)

# original comment -> # Print the result
# Check and print the results:
# Using the 'GetPropertyValuesOfElements' command with the 'elements' and propertyId list arguments
# preapre a list with modified properties of the parking spaces.
newValues = acc.GetPropertyValuesOfElements(elements, [propertyId])
# Using list comprehension preapre a list of tuples with elements ids and their property values respectively.
elemAndValuePairs = [(elements[i].elementId.guid, v.propertyValue.value) for i in range(len(newValues)) for v in newValues[i].propertyValues]
# Print the elem 'elemAndValuePairs' list sort by the property values.
# Calling the sorted method on the list using sorting key to be the property value of the tuple.
for elemAndValuePair in sorted(elemAndValuePairs, key=lambda p: p[1]):
    print(elemAndValuePair)
