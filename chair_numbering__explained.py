# import archicad connection (required)
from archicad import ACConnection
# import typing and string not essential for the code
from typing import List, Tuple, Iterable
# import string to define the row character index in the 'GeneratePropertyValueString' function
import string

# Establish the connection with the Archicad software, Archicad must be open and the pln file must be open too.
#
# We can use the acu.OpenFile() utility but we need an established connection first so we need to open Archicad and a new plan
# as a minimum because all utilities use the connection.
conn = ACConnection.connect()
# assert that the connection is alive
assert conn

# Create shorts of the commands, types and utilities.
acc = conn.commands
act = conn.types
acu = conn.utilities

# original comment -> ################################ CONFIGURATION #################################
# Getting the property Id (guid) for the General_ElementID property in order to use this to identify
# the property exactly when we communicate with the API (this is a unique identifier like our social security number). 
propertyId = acu.GetBuiltInPropertyId('General_ElementID')

# This is a method for collecting all the chairs from the Archicad pln file in a list.
# We need the 'guid' of the classificationItem in order to uniquely identify the classification
# based on we want to collect the elements with the Get elements by classification method.
classificationItem = acu.FindClassificationItemInSystem(
    'ARCHICAD Classification', 'Chair')
# We collect the chairs in the element list using the chair classification 'guid' from above.
# The elements list contains the 'guids' of the chairs. The length of the list is 125 since we have 125 chairs.
elements = acc.GetElementsByClassification(
    classificationItem.classificationItemId)

# This variable is to consider some kind of tolerance in the 'z' coordinate of the chair positions
# when we are sorting them by the level where they are placed.
# For that particular example this wouldn't be necessary since all the chairs are exactly leveled
# and placed exactly on the same levels on the different slabs. 
ROW_GROUPING_LIMIT = 0.25

# With this function we generate a string property value for the General elemnt Id since this is a string type Id.
# Takes as argument the rowindex (A, B, C etc.), index in row (1, 2, 3, etc.) is right (True or False)
# returns a string e.g.: 'A.1/Right' 
def GeneratePropertyValueString(rowIndex: int, indexInRow: int, isRight: bool) -> str:
    return f'{string.ascii_uppercase[rowIndex]}.{indexInRow}/{"Right" if isRight else "Left"}'
# original comment -> ################################################################################

# This function prepares NormalStringPropertyValue type from the string generated by the function 'GeneratePropertyValueString'.
# The function of GeneratePropertyValueString could be combined with this since these two functions are working always together.
def generatePropertyValue(rowIndex: int, indexInRow: int, isRight: bool) -> act.NormalStringPropertyValue:
    return act.NormalStringPropertyValue(GeneratePropertyValueString(rowIndex, indexInRow, isRight))

# This function is just getting the z Min position of the actual chair element.
# Since it receives a tuple like arguments with two values (first value is the element id, second value is the bounding box)
# we need to get the z Min from the second value.  
def getXMin(elemWithBoundingBox: Tuple[act.ElementIdArrayItem, act.BoundingBox3DWrapper]) -> float:
    return elemWithBoundingBox[1].boundingBox3D.xMin

# This function generate the new property values for the chairs.
# Receive the element with bounding box list which contains the element ids followed by their bounding boxes respectively.
# Returns a list with the 'ElementPropertyValue' of every chairs.
# ElementPropertyValue is a class contains the elementId, propertyId and property value.
# The property value in our case a string since we are changing the 'General_ElementID's of the chairs.
# The type of the 'General_ElementID' is string.
def generateNewPropertyValuesForElements(elemsWithBoundingBox: Iterable[Tuple[act.ElementIdArrayItem, act.BoundingBox3DWrapper]], isRight: bool, rowIndex: int):
    # Create the empty property value list. 
    propertyValues = []
    # Start index in row is '1'.
    indexInRow = 1
    # The loop generates and appends the 'ElementPropertyValue's.
    # Using the sorted method on the 'elemsWithBoundingBox', the bases of the sorting is the xMin,
    # xMin min is the first (index 1 and from here increasing) if the chair is on the left,
    # xMin max is the first (index 1 and from here increasing) if the chair is on the right
    for (elem, _) in sorted(elemsWithBoundingBox, key=getXMin, reverse=isRight):
        # Append to the 'propertyValues' list the generated property value classes.
        # Arguments: element id, property id, calling the 'generatePropertyValue'
        # to generate the General element id string.
        propertyValues.append(act.ElementPropertyValue(
            elem.elementId, propertyId, generatePropertyValue(rowIndex, indexInRow, isRight)))
        indexInRow += 1
    return propertyValues

# Create a list of the different slab levels with chairs.
# Arguments: List of elements' zMin values, tolerance limit.
# Returns list of tuples(zMin, zMax) with the different levels.
# zMin and zMax are always equal in our case. 
def createClusters(positions: Iterable[float], limit: float) -> List[Tuple[float, float]]:
    # When we are getting the chairs to the elements list the order of the chairs is not following the slab levels.
    # For that reason 'positions' needs to be sorted to avoid level duplicates in the 'clusters' list.
    positions = sorted(positions)
    # If there is no elements nothing to sort so return an empty list.
    # In our case we always have elemnts so this check is redundant.
    if len(positions) == 0:
        return []

    # Create empty list for the levels
    clusters = []
    # Make the 'position' list iterabel. The list is iterable so this is not required.
    posIter = iter(positions)
    # All postions are equel to the first position in the 'positions' list.
    # In our case we would only need 1 position i.e. firstPos.
    firstPos = lastPos = next(posIter)

    # Loop all the position and append to the 'clusters' list the different slab levels only.
    for pos in posIter:
        # If the actual position - lastPos which is the start at the beginning <= limit (could be == 0).
        if pos - lastPos <= limit:
            # Take the actual position as the last one and continue with the next level.
            lastPos = pos
        # Else (the actual position - last position > limit (could be > 0)).
        else:
            # Append the first and last position tuple to the clusters list.
            # Fisrt position and last position are always equal in our case.
            clusters.append((firstPos, lastPos))
            # Update all the positions to be equal to pos and continue with the next level.
            firstPos = lastPos = pos

    # Since there is no next level after the last one,
    # for the last level the else statement will never happen.
    # In order to be this level in the 'clusters' list we need to append this after the loop finishes.
    clusters.append((firstPos, lastPos))
    return clusters

# Getting all 3d bounding boxes of all the chairs.
# The bounding box contains the x, y, z minimum and maximum values of the box
# can be drawn around the element containging the whole element!
# Returns a list.
boundingBoxes = acc.Get3DBoundingBoxes(elements)

# Here we calculate the avarage x position of the chairs to get the middle point x coordinate
# This will help us define if the chair is Right or Left
averageXPosition = sum([bb.boundingBox3D.xMin for bb in boundingBoxes]) / len(boundingBoxes)

# We create the list of the slab levels of the auditorium where the chairs are located.
# Arguments: zMin values of the chairs, limit which is the tolerance of the level.
zClusters = createClusters((bb.boundingBox3D.zMin for bb in boundingBoxes), ROW_GROUPING_LIMIT)

# List of each elements and its bounding box follows.
# Calling zip method on the elements list and the bounding box list. 
elementsWithBoundingBoxes = list(zip(elements, boundingBoxes))

# rowindex will increase when all chairs in the actual row have their property values generated
# and appended to the elemPropertyValues list.
rowIndex = 0
elemPropertyValues = []

# Loop through all the slab levels taking the zMin and zMax.
# These two values are the same practically and in that sense only the zMin positin would be enough.
for (zMin, zMax) in zClusters:
    # Using list comprehension we prepare a list with the chairs in the same row (same level)
    # including all the chairs on the right and on the left side too. 
    elemsInRow = [e for e in elementsWithBoundingBoxes if zMin <= e[1].boundingBox3D.zMin <= zMax]
    # Create separate lists for the sides.
    rightSide, leftSide = [], []
    # Append to the appropriate list the chairs on the left and on the right side. 
    for elemWithBoundingBox in elemsInRow:
        # Calling the getXmin function to define the zMin position of the actual element
        # and if it is smaller then the average X psoition the chair is on the left side.
        # It is appended to the leftSide list.
        if getXMin(elemWithBoundingBox) > averageXPosition:
            leftSide.append(elemWithBoundingBox)
        # else (it must be greater then the avarage x position) the chair is on the right side.
        # It is appended to the rightSide list.
        else:
            rightSide.append(elemWithBoundingBox)

    # Using the extend method to add both left and right side list to the elem property values list.
    # The end of these loops thie list will contain all the new property values of the chairs.
    elemPropertyValues.extend(generateNewPropertyValuesForElements(rightSide, True, rowIndex))
    elemPropertyValues.extend(generateNewPropertyValuesForElements(leftSide, False, rowIndex))
    # Increase the rowindex (go to next row) since we finished with the actual row.
    rowIndex += 1

# Set the new property values.
# Argument: elemPropertyValues list.
acc.SetPropertyValuesOfElements(elemPropertyValues)

# original comment -> # Print the result

# Check and print the results:
# Using the 'GetPropertyValuesOfElements' command with the 'elements' and propertyId list arguments
# preapre a list with the chair modified properties.
newValues = acc.GetPropertyValuesOfElements(elements, [propertyId])
# Using list comprehension preapre a list of tuples with elements ids and their property values respectively.
elemAndValuePairs = [(elements[i].elementId.guid, v.propertyValue.value) for i in range(len(newValues)) for v in newValues[i].propertyValues]
# Print the elem 'elemAndValuePairs' list sort by the property values.
# Calling the sorted method on the list using sorting key to be the property value of the tuple.
for elemAndValuePair in sorted(elemAndValuePairs, key=lambda p: p[1]):
    print(elemAndValuePair)