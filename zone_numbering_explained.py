# import archicad connection (required)
from archicad import ACConnection
# import typing and string not essential for the code
from typing import List, Tuple, Iterable
# import itertools cycle method but in this particular code
# it wouldnt be necessary to use cycle.
from itertools import cycle

# Establish the connection with the Archicad software, Archicad must be open and the pln file must be open too.
#
# We can use the acu.OpenFile() utility but we need an established connection first so we need to open Archicad and a new plan
# as a minimum because all utilities use the connection.
conn = ACConnection.connect()
# assert that the connection is alive
assert conn

# Create shorts of the commands, types and utilities.
acc = conn.commands
act = conn.types
acu = conn.utilities

# original comment -> ################################ CONFIGURATION #################################
# Getting the property Id (guid) for the General_ElementID property
# in order to use this to identify
# the property exactly when we communicate with the API
# (this is a unique identifier like our social security number).
propertyId = acu.GetBuiltInPropertyId('Zone_ZoneNumber')

propertyValueStringPrefix = ''
# We collect all the 'Zone' element into the 'elements' list
# using the 'Zone' type with the GetElementsByType command.
# The elements list contains the 'guids' of all the the zones in the project.
elements = acc.GetElementsByType('Zone')

# These variables are to consider some kind of tolerance in the 'z' and ''y coordinate of the zone positions
# when we are sorting them by the level and the side of the building where they are.
# For that particular example this wouldn't be necessary since all the zones are placed exactly on the same levels
# and they are sharing the exact same y coordinates.
# These tolerances are useful, when we want to select some elements in a certain strip or area.
# To consider some tolerances for example we can give upper and lower limit too.
ROW_GROUPING_LIMIT = 0.25
STORY_GROUPING_LIMIT = 1

# With this function we generate a string property value for the 'Zone_ZoneNumber'
# since this is a string type property.
# Takes as argument the storyIndex (1, 2), elemIndex (01, 02, etc.) and
# returns a string e.g.: '112'
def GeneratePropertyValueString(storyIndex: int, elemIndex: int) -> str:
    # storyIndex 1 digits, elemIndex 2 digits and below 10 it starts with 0.
    return f"{propertyValueStringPrefix}{storyIndex:1d}{elemIndex:02d}"
# original comment -> ################################################################################

# This function prepares NormalStringPropertyValue type from the string
# generated by the function 'GeneratePropertyValueString'.
# The function of GeneratePropertyValueString could be combined with this
# since these two functions are working always together.
def generatePropertyValue(storyIndex: int, elemIndex: int) -> act.NormalStringPropertyValue:
    return act.NormalStringPropertyValue(GeneratePropertyValueString(storyIndex, elemIndex))

# Create a list of the different levels and building sides.
# Arguments: List of elements' zMin values, yMin values, tolerance limit.
# Returns list of tuples(zMin, zMax) with the different levels or
# (yMin, yMax) with the different side y coordinate.
# The Min and Max values are always equal in our case.
def createClusters(positions: Iterable[float], limit: float) -> List[Tuple[float, float]]:
    # When we are getting the zones to the elements list
    # the order of the zones is not following our particular logic.
    # For that reason 'positions' needs to be sorted to avoid duplicates in the 'clusters' list.
    positions = sorted(positions)
    # If there is no elements nothing to sort so return an empty list.
    # In our case we always have elemnts so this check is redundant.
    if len(positions) == 0:
        return []
    # Create empty list for the end result
    clusters = []
    # Make the 'position' list iterabel. The list is iterable so this is not required.
    posIter = iter(positions)
    # All postions are equel to the first position in the 'positions' list.
    # In our case we would only need 1 position i.e. firstPos.
    firstPos = lastPos = next(posIter)

    # Loop all the position and append to the 'clusters' list
    for pos in posIter:
    # the different levels or side y coordinate only.
    # If the actual position - lastPos which is the start at the beginning <= limit (could be == 0).
        if pos - lastPos <= limit:
            # Take the actual position as the last one and continue with the next position.
            lastPos = pos
            # Else (the actual position - last position > limit (could be > 0)).
        else:
            # Append the first and last position tuple to the clusters list.
            # Fisrt position and last position are always equal in our case.
            clusters.append((firstPos, lastPos))
            # Update all the positions to be equal to pos and continue with the next position.
            firstPos = lastPos = pos
    # The last position will not reach the else statement because of the lack of next different value,
    # In order to be this value also added to the 'clusters' list we need to append this after the loop finishes.
    clusters.append((firstPos, lastPos))
    return clusters

# Getting all 3d bounding boxes of all the zones.
# The bounding box contains the x, y, z minimum and maximum values of the box
# can be drawn around the element containging the whole element!
# Returns a list.
boundingBoxes = acc.Get3DBoundingBoxes(elements)
# List of each elements and its bounding box follows.
# Calling zip method on the elements list and the bounding box list.
elementBoundingBoxes = list(zip(elements, boundingBoxes))
# We create the list of the different values of the levels where the zones are located on.
# Arguments: zMin values of the zones, limit which is the tolerance of the level.
zClusters = createClusters((bb.boundingBox3D.zMin for bb in boundingBoxes), STORY_GROUPING_LIMIT)

# StoryIndex will increase when all zones on the actual level have their property values generated
# and appended to the elemPropertyValues list.
storyIndex = 0
elemPropertyValues = []
# Loop through all the zones taking the zMin and zMax.
# These two values are the same practically and in that sense only the zMin positin would be enough.
for (zMin, zMax) in zClusters:
    # Initialise elemIndex with 1 as the first zone element on the actual floor
    elemIndex = 1
    # Using list comprehension we prepare a list with the all the zones on the same level 
    elemsOnStory = [e for e in elementBoundingBoxes if zMin <= e[1].boundingBox3D.zMin <= zMax]
    # Based on the above created list with all the zones on the actual floor
    # we are creating 'clusters' list with the side y coordinates.
    yClusters = createClusters((e[1].boundingBox3D.yMin for e in elemsOnStory), ROW_GROUPING_LIMIT)

    # This loop takes the y Min and Y Max coordinates and the side boolean list zipped and
    # prepares the final values of the zone numbers.
    for ((yMin, yMax), reverseOrder) in zip(yClusters, cycle([False, True])):
        # With list comprehension we are taking the zones on the actual level for the actual side only.
        elemsInRow = [e for e in elemsOnStory
                        if yMin <= e[1].boundingBox3D.yMin <= yMax]

        # This loop generate the property values of the zones on the actual level and actual side
        # Taking the list of the elementsInRow sorted by the xMin values and ordered by the boolean value
        # which depends on the side.
        for (elem, bb) in sorted(elemsInRow, key=lambda e: e[1].boundingBox3D.xMin, reverse=reverseOrder):
            # Preparing and appending the property values to the final elemPropertyValues list
            # Archicad API type used: ElementPropertyValue()
            # Arguments: elementId, propertyId,
            # the string of the value created by the generatePropertyValue function
            # taking as arguments the storyIndex (level), elemIndex (index number).
            elemPropertyValues.append(act.ElementPropertyValue(
                elem.elementId, propertyId, generatePropertyValue(storyIndex, elemIndex)))
            # Increase elemIndex to go to the next element.
            elemIndex += 1
    # Increase the storyIndex to go to the next story
    storyIndex += 1

# Set the new property values.
# Argument: elemPropertyValues list.
acc.SetPropertyValuesOfElements(elemPropertyValues)

# original comment -> # Print the result
# Check and print the results:
# Using the 'GetPropertyValuesOfElements' command with the 'elements' and propertyId list arguments
# preapre a list with the zones modified properties.
newValues = acc.GetPropertyValuesOfElements(elements, [propertyId])
# Using list comprehension preapre a list of tuples with elements ids and their property values respectively.
elemAndValuePairs = [(elements[i].elementId.guid, v.propertyValue.value) for i in range(len(newValues)) for v in newValues[i].propertyValues]
# Print the elem 'elemAndValuePairs' list sort by the property values.
# Calling the sorted method on the list using sorting key to be the property value of the tuple.
for elemAndValuePair in sorted(elemAndValuePairs, key=lambda p: p[1]):
    print(elemAndValuePair)
